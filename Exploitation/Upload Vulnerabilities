#----Overview
Webpages that allow users to upload data, such as photos, blogs etc. May be able to upload shells, overwrite files, bypass client and/or svr filtering

#----Overwriting Existing Files
On the off-chance that a webpage is writeable by a user, we can overwrite existing files when uploading. One method is by looking @ the src code html and trying to determine where existing files may be located and what their naming convention is. Uploading w/ same name/location may overwrite

#---RCE
Uploading malicious data that the back-end understands, often php, python or js. Often uses webshells or revshells. W/ Webshells, a good place to start is:
1) Enumeration of directories via smth like gobuster
2) A simply php webshell may be: 
<?php
  echo system($_GET["cmd"]);
?>
3) If uploaded, we can try and pass commands to it in the URL e.g. site.com/uploads/shell.php?cmd=<cmd here>
This is an embedded webshell that will echo out the results of the cmds we pass. The exact same concept applies to uploading rev. shells, except we just open a listener on our system

#----Filtering
Client-Side filtering is trival to bypass. This typically takes the form of javascript that we interact w/ when accessing a webpage. Svr-side will often be php, python, Node.js. Server-side filtering is more difficult to bypass because we do not know the code associated with it. We instead go in somewhat blind, using trial/error to infer what filtering is in place WRT what can be uploaded. We cannot normally edit svr-side filter, so instead we infer what the filter is filtering for, and conform the malicious payload to adhere to those filters, while still maintaining functionality

There are multiple types of filtering:
1) Ext. - White/Blacklist extensions. Superficial
2) File Type Filters - Use MIME Type which is normally attached to the header of a http request. Still superficial and easily edit'able
3) File Length - Filters files that exceed certain lengths. 
4) File name - Uploaded files are often given randomized names, or at least appended w/ smth random or perhaps that date of upload to avoid svr-side duplication of files. Also sanitizaition for file names w/ special characters
5) File content filter - Looks @ contents w/i in the file itself 


#----Bypassing Client-side filters
The idea is simple. W/ a proxy like BURP sitting b/t our browser and the svr, we can:
1) Send an HTTP Request that conforms to the client-side filters, capture in BURP and edit prior to sending to svr
2) Turn off Javascript in our browser. This works if the site still functions more or less w/o js. If the browser is not accepting js, then no client-side filters are dl'd
3) Intercept in ingress HTML page from the svr, and just remove the javascript/filters inside the html recieved prior to it hitting our browser **(May need to ctrl+f5 refresh if we already cached the JS w/ the filters)
4) Send file directly to the upload point svr-side i.e. curl -x POST -F "submit:<value>" -F "<file para.>":@<path to file>" <site>. This bypasses client-side b/c we're not sending it thru some browser. Just direct

ex. <script> if (file.type != "image/jpeg") { alert=(etc.etc)} </script>


#----Server Side bypass
More difficult because we cannot see the code and therefore its more trial and error to derive what/how the server is filtering. For example, if its by extension, the server-side might be splitting the into [name].[extension] by using the "." as a delim. 

1) Change the extension and see what happens. If it's php, try php3, php4, phtml, phar, php5 etc. and any other extensions that will still allow the file to function and perhaps bypass a filter
2) If we know a certain extension is whitelisted (we can successfully upload .jpg for ex) then try shell.jpg.php. Perhaps the filter is just looking for jpg 
3) Magic number bypassing can be done by first prepending random data to the beginning of a file: AAAA. Then w/ hexeditor, edit the hex to match the magic number of a whitelisted file type. e.g. FF D8 FF for jpg. 


#----Methodology/Steps to take
1) Look at the website as a whole. Ask yourself:
- What language is the backend
- What happens if I go to an invalid webpage. Do I get info on web svr
- Intercept a response w/ Burp and view server info via "x-powered-by" or "server"
- Gobuster, Dnsrecon, enumerate subdomains
- Examine source code for clues
- Examine for vectors of attack. Input field for a user/upload?

2) Examine filters in code if present. If not, what uploads work, what do not. Narrow down what svr-side filtering is looking at. 
- Change magic #
- Change ext
- Edit MIME and filename is header w/ Burp interrupt

3) Try innocent file upload. Where does the file get uploaded to? What dir? Can we access it? Does the file's naming scheme get changed? Gobuster's -x txt,php,html can help with this to find the file

4) Attempt malicious upload
